<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dynamic Gantt Chart</title>
    
    <!-- 1. Load Tailwind CSS (and its "preflight" base styles) FIRST -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. Load html2canvas for exporting -->
    <script 
      src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" 
      xintegrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+cHio/BJLMBKSnQYjDRMvMMlPzgw6D/LIIXbaK3ddhiNRVbcC+WfcD+WjGg==" 
      crossorigin="anonymous" 
      referrerpolicy="no-referrer"
    ></script>

    <!-- 
      *** FIX: MOVED STYLESHEET HERE ***
      Load our custom styles *after* the Tailwind script.
      This ensures our chart styles (.gantt-grid, .gantt-bar) 
      override Tailwind's base "preflight" resets.
    -->
    <link rel="stylesheet" href="/style.css" />
    
    <!-- 3. Configure Tailwind with custom theme -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'custom-text': '#0c2340',
                        'custom-outline': '#da291c',
                        // Use the red color for the button
                        'custom-button': '#da291c',
                        'custom-button-hover': '#a91f15', // A darker red for hover
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                },
            },
            plugins: [],
        }
    </script>
    
    <!-- 4. Add custom styles -->
    <style>
        /* Apply the custom text color globally */
        body, h1, h2, p, div, span, label, input::placeholder, textarea::placeholder {
            color: #0c2340;
        }

        /* Style the placeholder with the custom color and slight opacity */
        .custom-placeholder::placeholder {
            color: #0c2340;
            opacity: 0.6;
        }

        /* Custom focus ring for form elements */
        .custom-focus:focus {
            outline: none;
            border-color: transparent;
            box-shadow: 0 0 0 2px #da291c; /* Use box-shadow for a ring effect */
        }
    </style>
</head>
<body class="bg-gray-50 font-sans relative min-h-screen overflow-hidden">

    <!-- 
      Dynamic Roadmap Background SVG
    -->
    <svg id="roadmap-svg" class="absolute w-full -z-10" preserveAspectRatio="none">
        <!-- Lines will be dynamically added here by JS -->
        <g id="roadmap-lines"></g>
        <!-- Points will be dynamically added here by JS -->
        <g id="roadmap-points"></g>
    </svg>

    <!-- Main container -->
    <div class="relative min-h-screen flex flex-col items-center justify-center p-6 md:p-12">

        <!-- New Logo Header -->
        <header class="absolute top-8 left-8 md:top-12 md:left-12">
            <img src="https://placehold.co/150x50/0c2340/FFFFFF?text=BIP+Logo&font=inter" alt="BIP Logo" class="h-12 w-auto" 
                 onerror="this.onerror=null; this.src='https://placehold.co/150x50/0c2340/FFFFFF?text=BIP+Logo&font=inter';">
        </header>

        <!-- Content -->
        <main class="w-full max-w-3xl z-10">
            <!-- Header Text -->
            <div class="text-center mb-10" id="title-block">
                <h1 class="text-4xl md:text-5xl font-bold mb-3">
                    Research Roadmap Generator
                </h1>
                <p class="text-lg opacity-80 max-w-xl mx-auto">
                    Transform your research documents into interactive Gantt charts with AI-powered analysis
                </p>
            </div>

            <!-- 
              Main Form
              This is the original <form> element from your app,
              styled with the new Tailwind classes.
            -->
            <form id="gantt-form" class="bg-white rounded-2xl shadow-xl p-8 md:p-12 w-full">
                
                <!-- Project Instructions Section -->
                <section class="mt-8">
                    <h2 class="text-2xl font-semibold mb-4">
                        Project Instructions
                    </h2>
                    
                    <textarea id="prompt-input" rows="4" class="w-full p-4 border border-gray-300 rounded-lg resize-none custom-placeholder custom-focus transition-shadow" 
                              placeholder="Describe your project goals, timeline preferences, key milestones, or any specific requirements for the roadmap generation..."></textarea>
                </section>
                
                <!-- Upload Section -->
                <section class="mt-8">
                    <h2 class="text-2xl font-semibold mb-4">
                        Upload Research Documents
                    </h2>
                    
                    <!-- 
                      File Dropzone / Input
                      This now includes the actual <input type="file">
                    -->
                    <!-- MODIFICATION: Added min-h-[250px] to prevent layout shift -->
                    <label for="file-input" class="border-2 border-dashed border-custom-outline rounded-lg p-10 md:p-12 flex flex-col items-center justify-center text-center cursor-pointer hover:bg-gray-50 transition-colors min-h-[250px]">
                        
                        <!-- MODIFICATION: Added container for the default prompt -->
                        <div id="dropzone-prompt" class="flex flex-col items-center justify-center">
                            <!-- Upload Icon SVG (color set to custom-text) -->
                            <svg class="w-12 h-12 opacity-80" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 16.5V9.75m0 0l3 3m-3-3l-3 3M6.75 19.5a4.5 4.5 0 01-1.41-8.775 5.25 5.25 0 0110.233-2.33 3 3 0 013.758 3.848A3.752 3.752 0 0118 19.5H6.75z" />
                            </svg>
                            
                            <p class="text-lg font-medium mt-4">
                                Drop files here or click to browse
                            </p>
                            <p class="text-sm opacity-60 mt-1">
                                Supports .doc, .docx, .md, and .txt files
                            </p>
                        </div>

                        <!-- MODIFICATION: Added container for the file list (hidden by default) -->
                        <div id="file-list-container" class="hidden w-full">
                            <p class="text-lg font-semibold mb-3">Selected Files:</p>
                            <ul id="file-list" class="list-disc list-inside text-left text-sm space-y-1 max-h-32 overflow-y-auto">
                                <!-- File names will be injected here by JS -->
                            </ul>
                            <p class="text-sm opacity-60 mt-4">Click again or drop files to change selection</p>
                        </div>
                    </label>
                    
                    <!-- The actual file input, hidden but functional -->
                    <input type="file" id="file-input" multiple accept=".md, .txt, .docx, application/vnd.openxmlformats-officedocument.wordprocessingml.document" class="hidden">
                </section>
                
                <!-- Form Actions (Button & Loader) -->
                <div class="form-actions mt-10">
                    <div class="flex items-center gap-6">
                        <button type="submit" id="generate-btn" class="text-white bg-custom-button hover:bg-custom-button-hover focus:ring-4 focus:ring-custom-outline font-semibold rounded-lg text-base px-8 py-3 transition-colors disabled:opacity-50">
                            Generate Chart
                        </button>
                        
                        <div id="loading-indicator" class="flex items-center gap-3" style="display: none;">
                            <div class="spinner w-6 h-6 border-3 border-gray-200 border-t-custom-button rounded-full animate-spin"></div>
                            <span class="text-lg">Analyzing...</span>
                        </div>
                    </div>
                </div>

            </form>
            
            <!-- Error Message Box -->
            <div id="error-message" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative my-6" style="display: none;"></div>

            <!-- Chart will be rendered here -->
            <div id="chart-output" class="w-full">
                <!-- This is where main.js will build the chart -->
            </div>
            
        </main>
    </div>

    <!-- Script for Dynamic SVG Background -->
    <script>
        // Wait for the window to load
        window.onload = function() {
            
            // --- DOM Elements ---
            let titleEl, formEl, svg, linesGroup, pointsGroup;

            // --- Animation Parameters ---
            const pointColor = 'rgba(218, 41, 28, 0.4)'; // #da291c
            const lineColor = 'rgba(218, 41, 28, 0.3)';  // #da291c
            const numMilestonesPerSide = 3; // 3 dots on each side
            const pointRadius = 5;
            const zigZagAmount = 80; // How much horizontal variation

            // --- Animation State ---
            let milestones = []; // Array of {x, y, length} milestone coordinates
            let milestoneElements = []; // Array of <circle> elements
            let tracerPath; // The single <path> element for the moving line
            let totalPathLength = 0;
            
            // Animation state for Draw-On / Recede effect
            let animationPhase = "drawing"; // "drawing" or "receding"
            let headPosition = 0;
            let tailPosition = 0;
            const animationSpeed = 2; // Speed for both drawing and receding

            // SVG Namespace for creating elements
            const svgNS = "http://www.w3.org/2000/svg";

            /**
             * Updates all coordinate calculations.
             * Called on init and on window resize.
             */
            function updateDimensions() {
                // Get dimensions of content
                const titleRect = titleEl.getBoundingClientRect();
                const formRect = formEl.getBoundingClientRect();
                const topOffset = titleRect.top + titleRect.height + 20;
                const availableHeight = window.innerHeight - topOffset;
                
                // Set SVG dimensions
                svg.style.top = `${topOffset}px`;
                svg.style.height = `${availableHeight}px`;
                svg.setAttribute('viewBox', `0 0 ${window.innerWidth} ${availableHeight}`);
                
                const cardLeft = formRect.left;
                const cardRight = formRect.right;
                const gutterLeft = cardLeft * 0.5; // Center of left gutter
                const gutterRight = cardLeft + (window.innerWidth - cardRight) * 0.5; // Center of right gutter
                
                const numTotalMilestones = numMilestonesPerSide * 2;
                const verticalSpacing = availableHeight / (numMilestonesPerSide + 1);

                milestones = []; // Clear old milestones
                
                // Add virtual start point
                milestones.push({ x: -200, y: verticalSpacing, length: 0 });

                // Add left-side dots (top to bottom)
                for (let i = 0; i < numMilestonesPerSide; i++) {
                    const x = gutterLeft + (Math.random() - 0.5) * zigZagAmount;
                    const y = verticalSpacing * (i + 1);
                    milestones.push({ x, y, length: 0 });
                }
                
                // Add right-side dots (BOTTOM to TOP) - This is the reverted logic
                for (let i = 0; i < numMilestonesPerSide; i++) {
                    const x = gutterRight + (Math.random() - 0.5) * zigZagAmount;
                    const y = verticalSpacing * (numMilestonesPerSide - i); // <-- Reverted
                    milestones.push({ x, y, length: 0 });
                }

                // Add virtual end point
                milestones.push({ x: window.innerWidth + 200, y: verticalSpacing, length: 0 }); // <-- Reverted
                
                // Path has changed, rebuild it
                buildStaticPath();
            }

            /**
             * Builds the <path> element, dots, and calculates lengths.
             */
            function buildStaticPath() {
                if (milestones.length === 0) return;
                
                // Clear old elements
                pointsGroup.innerHTML = '';
                milestoneElements = [];
                
                let d = `M ${milestones[0].x} ${milestones[0].y}`;
                for (let i = 1; i < milestones.length; i++) {
                    d += ` L ${milestones[i].x} ${milestones[i].y}`;
                }

                // Use a temporary path to measure lengths
                let tempPath = document.createElementNS(svgNS, 'path');
                tempPath.setAttribute('d', d);
                totalPathLength = tempPath.getTotalLength();

                // Draw static milestone dots and store them
                for (let i = 1; i < milestones.length - 1; i++) { // Skip virtual points
                    const dot = document.createElementNS(svgNS, 'circle');
                    dot.setAttribute('cx', milestones[i].x);
                    dot.setAttribute('cy', milestones[i].y);
                    dot.setAttribute('r', pointRadius);
                    dot.setAttribute('fill', pointColor);
                    dot.style.opacity = 0; // Start hidden
                    dot.style.transition = 'opacity 0.3s ease';
                    pointsGroup.appendChild(dot);
                    milestoneElements.push(dot);
                    
                    // Get length at this dot
                    // Create a *new* path segment for measuring
                    let measurePath = document.createElementNS(svgNS, 'path');
                    let measureD = `M ${milestones[0].x} ${milestones[0].y}`;
                    for (let j = 1; j <= i; j++) {
                        measureD += ` L ${milestones[j].x} ${milestones[j].y}`;
                    }
                    measurePath.setAttribute('d', measureD);
                    milestones[i].length = measurePath.getTotalLength();
                    measurePath = null; // Clean up
                }
                
                // Set the final path for the visible tracer
                tracerPath.setAttribute('d', d);
                
                // Clean up the temp path
                tempPath = null;
            }

            /**
             * One-time setup.
             */
            function init() {
                // Create the main <path> element for the line
                tracerPath = document.createElementNS(svgNS, 'path');
                tracerPath.setAttribute('stroke', lineColor);
                tracerPath.setAttribute('stroke-width', '2');
                tracerPath.setAttribute('fill', 'none');
                linesGroup.appendChild(tracerPath);
                
                // Set initial dimensions and build the path
                updateDimensions();
                
                // Add resize listener
                window.addEventListener('resize', updateDimensions);
            }

            /**
             * The main animation loop.
             */
            function animate() {
                // Safety check: Don't run if path isn't ready
                if (!tracerPath || !totalPathLength || totalPathLength === 0) {
                    requestAnimationFrame(animate); // Wait
                    return;
                }

                // --- Draw-On / Recede Animation Logic ---

                if (animationPhase === "drawing") {
                    headPosition += animationSpeed;
                    
                    const dashLength = headPosition;
                    const gapLength = totalPathLength - dashLength;
                    
                    if (tracerPath.style) {
                        tracerPath.style.strokeDasharray = `${dashLength} ${gapLength}`;
                        tracerPath.style.strokeDashoffset = 0;
                    }

                    if (headPosition >= totalPathLength) {
                        headPosition = totalPathLength;
                        animationPhase = "receding";
                    }

                } else if (animationPhase === "receding") {
                    tailPosition += animationSpeed;

                    if (tracerPath.style) {
                        tracerPath.style.strokeDasharray = `${totalPathLength} ${totalPathLength}`;
                        tracerPath.style.strokeDashoffset = -tailPosition;
                    }
                    
                    if (tailPosition >= totalPathLength) {
                        tailPosition = 0;
                        headPosition = 0;
                        animationPhase = "drawing";
                    }
                }

                // UPDATE DOT VISIBILITY
                for (let i = 0; i < milestoneElements.length; i++) {
                    // milestone[i+1] because [0] is virtual start
                    const dotLength = milestones[i+1].length; 
                    const dotElement = milestoneElements[i];

                    // Safety check: Check elements before styling
                    if (dotElement && dotElement.style) {
                        const isVisible = (dotLength > tailPosition && dotLength < headPosition);
                        dotElement.style.opacity = isVisible ? 1 : 0;
                    }
                }
                
                // Request the next animation frame
                requestAnimationFrame(animate);
            }

            /**
             * Robust Initialization:
             * Waits for key DOM elements to be ready AND RENDERED.
             */
            function retryInit(attemptsLeft = 10) {
                // Find all required elements
                titleEl = document.getElementById('title-block');
                formEl = document.getElementById('gantt-form');
                svg = document.getElementById('roadmap-svg');
                linesGroup = document.getElementById('roadmap-lines');
                pointsGroup = document.getElementById('roadmap-points');
                
                // Check if all elements were found AND are rendered
                let allElementsReady = false;
                if (titleEl && formEl && svg && linesGroup && pointsGroup) {
                    // Now, check if they are rendered
                    try {
                        const titleRect = titleEl.getBoundingClientRect();
                        const formRect = formEl.getBoundingClientRect();
                        // Check for valid, non-zero dimensions (or at least that they exist)
                        if (titleRect && formRect) {
                            allElementsReady = true;
                        }
                    } catch (e) {
                        // Bounding rect failed, not ready
                    }
                }
                
                if (allElementsReady) {
                    // All elements found and rendered, proceed
                    console.log("DOM elements are ready, initializing animation.");
                    init();
                    // Start the animation loop
                    animate();
                } else if (attemptsLeft > 0) {
                    // Elements not found or not rendered, wait and retry
                    console.log("Waiting for DOM elements to render...");
                    setTimeout(() => retryInit(attemptsLeft - 1), 200);
                } else {
                    // Failed after all attempts
                    console.error("Failed to initialize animation: DOM elements not found or not rendered.");
                }
            }
            
            // Start the initialization check
            retryInit();
        };
    </script>
    
    <!-- Load the main application logic -->
    <script type="module" src="/main.js"></script>
    
</body>
</html>